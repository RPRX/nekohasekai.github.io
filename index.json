[{"content":"vless 请求格式为：\nVersion UUID ProtoBuf request Command Destination (VMess) Payload 1b 16b variable 1b variable variable ProtoBuf 请求为：\nmessage Addons { string Flow = 1; bytes Seed = 2; } 分析该设计：\nXray 对 UUID 使用了 ReadFull，这意味着 VLESS 可能并没有与 Trojan 相同的探测保护，向其发送 1+15 字节后停止，服务器长时间等待将会 成为特征。\n对于其想新增的字符串参数，开创性地使用了被 V2Ray 滥用的应用层协议 ProtoBuf 格式，这样独特的行为可能会让其他开发者误会，对他的专业性产生怀疑。\n对于地址格式，直接使用了 VMess 的意义不明格式（该格式修改了表示 address type 的字节，并且将端口移动到地址之前），而不是 Trojan 使用的标准 socksaddr。\n至于什么兼容性，能做到在 patch release 中 break 协议的项目应该也不在乎这些。\nUDP FullCone 由于 V2Ray 项目原作者对 TCP/IP 的理解水平不足，V2Ray 中将 UDP 与 TCP 连接混为一谈，导致其在 UDP 传输上的设计存在严重缺陷，而其他项目根本不存在这个问题。\n而 VLESS 的设计直接沿用了 VMess 的 UDP 包不带地址的设计，这意味着他可以设计一个新的 “协议” 来修复这点。\n修改 v2ray 的 mux.cool 私有多路服用协议并取了一个易于宣传的名字作为私有协议，也是出于类商业运营考虑，因为这样可以即不打破与原始 VMess 协议的兼容性又可以从上游而吸引更多用户。\n回落 即使目前没有证据证明 GFW 会主动发起 HTTP 访问请求并根据回应来执行封锁，自欺欺人伪装界面仍然能吸引到许多缺乏相关知识的用户。\n原始 XTLS 现在我们知道该协议一开始就有可以被识别的问题。\n但在最初 naiveproxy 作者指出这点时，他的回复是 “不可能，你看代码了吗？“，直到两年后，klzgrad 指出的两个设计问题都被证明，他也没有正面回应，而是直接废弃了该协议。\nXTLS vision 这协议实现复杂，实际作用除了延续其广受好评的为了 “高性能“ 创造特征外，还为连接头部的数据添加了填充。\n该作者也找了许多其他开发者询问意见，然而：\n根据这项尚未发表的研究，连接头填充在它们自制的 TLS in crypto 识别模型不能起到有效的作用，而多路复用的协议能起到一定混淆流量特征的作用。 换句话说，该协议不仅复杂且未定义，而且对于反审查目的也毫无意义。\n我要指出的是，这项研究没有涉及现实世界的 GFW 行为，且没有证据证明 GFW 应用了此类机器学习识别。 考虑此类模型在误报率与性能，要想大规模部署都还需要很长时间。\n对于 TLS 代理，naiveproxy 在 2018 年就实现了多路复用、连接头部填充、使用 chromium 作为 TLS 实现。而此后再也没有真正意义上设计优于它的 TLS proxy 项目。\nGo 程序语言编写的 TLS 代理即使使用了 uTLS 这样伪装 TLS 指纹的库，也有报告其仍然被伊朗防火墙识别并封锁了。\nreality 跟随与发布于二月 19 日的 shadow-tls v3，Xray 与三月 9 日发布了 Xray 1.8.0 (pre-release)。\n该协议与 shadow-tls 都有报告已被伊朗防火墙识别并封锁了。\n即使作者自称在两年前就发明了这个协议，但也无法解释为什么在 shadow-tls 发布后的六个月才发布第一个版本，有趣的是，其自称文档和定义已经写好了 明天就发。\n","permalink":"https://sekai.icu/posts/the-myth-of-xtls/","summary":"什","title":"简述 XTLS 相关协议"},{"content":"距离 sing-box 1.0 发布将满一年，star 数量也来到了 4k，我想这是一个值得庆祝的日子。\n首先我要感谢对社区作出了很大贡献的开发者：\nwwqgtxx dyhkwong iKirby StudentMain 和其他贡献者：\nxiaokangwang XYenon zakuwaki 以及大量 typo 修复和不痛不痒更改请求的发起者无名朋友们。\n在这一年里，sing-box 作出了大量改进，包括：\n更好的 DNS 支持，包括所有 DNS transport、DNS 路由、reverse_mapping 和更好的 fake-ip 支持 （包括 IPv6、0 延迟 store_fakeip、与路由集成等独有功能）。 sing-tun 现在不仅是唯一一个开源的带有自动路由功能与 system stack 的 L3 透明代理程序库， 而且是唯一一个支持包括 iOS 在内的所有主流平台的。 最先与最好的 WireGuard 集成，包括 gVisor 非特权模式、 tun 特权模式 与自定义 reserved bytes 支持，此后 Golang 同类项目不管是否使用 GPL 授权，均有复制来自于 sing-box 的相关代码。 高性能 shadow-tls v1-v3实现 高性能 TUIC 实现、包括 udp_over_stream 支持 新的 UDP over TCP 与 Multiplex 协议 同时，我为 sing-box 编写了全新的 Android、iOS、 macOS 与 Apple tvOS 客户端，这些客户端不仅允许您管理并运行本地、iCloud 或远程 sing-box 配置，还提供了大量平台特定的功能实现与改进，包括：\nApple 平台唯一全系统支持的免费和开源代理项目 在 Apple 平台与 Android 提供休眠支持，在设备闲置时暂停包括 URLTest 与 WireGuard 定时器在内的定时任务 在 Android 平台提供首创的分应用代理与 中国应用 检测功能，并且支持在应用安装或更新时自动检测并作为分应用项选中 提供状态面板， URLTest、Selector 等出站组的状态显示与切换功能。 再次感谢为社区作出贡献的朋友们。\n","permalink":"https://sekai.icu/posts/a-year-of-sing-box/","summary":":)","title":"一年后的 sing-box"},{"content":"大多数服务器的行为会导致错误。\n目前没有一个代理协议规定了向服务器发送具有域名的 UDP 包后，服务器应如何处理响应中的地址。实际上，大多数代理程序服务器，如 Shadowsocks 官方实现 和 V2Ray，在响应中只返回 IP 地址。\n当代理程序向服务器发送域名时，它并不知道该域名对应的 IP 地址。当服务器在响应中发送 IP 地址时，该地址可能与客户端发起连接的目标地址不匹配。如果客户端验证该地址，该连接将失败。\n因此，像 Clash 和 Xray 这样支持 fake-ip 的透明代理客户端会强制在发起 UDP 代理连接之前将域名解析为 IP 地址。因此，实际上你几乎不能这样做。\n在 Clash 中：\nfunc handleUDPConn(packet *inbound.PacketAdapter) { ... // local resolve UDP dns if !metadata.Resolved() { ips, err := resolver.LookupIP(context.Background(), metadata.Host) if err != nil || len(ips) == 0 { packet.Drop() return } metadata.DstIP = ips[0] } ... } 在 Xray 中：\nfunc (d *DefaultDispatcher) getLink(ctx context.Context, network net.Network, sniffing session.SniffingRequest) (*transport.Link, *transport.Link) { ... if addr.Family().IsIP() { ... } else { if ip2domain == nil { ip2domain = new(sync.Map) newError(\u0026#34;[fakedns client] create a new map\u0026#34;).WriteToLog(session.ExportIDToError(ctx)) } domain := addr.Domain() ips, err := d.dns.LookupIP(domain, dns.IPOption{true, true, false}) if err == nil { for _, ip := range ips { ip2domain.Store(ip.String(), domain) } newError(\u0026#34;[fakedns client] candidate ip: \u0026#34;+fmt.Sprintf(\u0026#34;%v\u0026#34;, ips), \u0026#34; for xUDP buffer at \u0026#34;, i).WriteToLog(session.ExportIDToError(ctx)) } else { newError(\u0026#34;[fakedns client] failed to look up IP for \u0026#34;, domain, \u0026#34; for xUDP buffer at \u0026#34;, i).Base(err).WriteToLog(session.ExportIDToError(ctx)) } } ... } 如果您确实想尝试，则请确保您使用 sing-box :)\n","permalink":"https://sekai.icu/posts/udp-fqdn-in-transport-proxy/","summary":"大多数服务器的行为会导致错误。","title":"为什么你不想在透明代理 UDP 时传送域名目标地址到服务器"},{"content":"嗯。\n","permalink":"https://sekai.icu/posts/hello/","summary":"您好。","title":"Hello"}]